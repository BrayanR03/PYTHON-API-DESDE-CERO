from fastapi import status ## ‚¨ÖÔ∏è Importamos librer√≠a para el status 
from fastapi import HTTPException ## ‚¨ÖÔ∏è Importamos librer√≠a para el manejo correcto de errores en los endpoints
from pydantic import BaseModel ## ‚¨ÖÔ∏è Importamos librer√≠a para el formato adecuado de datos
from fastapi import APIRouter ## ‚¨ÖÔ∏è Importamos librer√≠a APIRouter para organizar y modularizar el c√≥digo de una API.

## üí° Librer√≠as de Autenticaci√≥n
from fastapi.security import OAuth2PasswordBearer
from fastapi.security import OAuth2PasswordRequestForm
import jwt ## ‚¨ÖÔ∏è Librer√≠a de JWT (JSON WEB TOKEN)
from jwt.exceptions import InvalidTokenError ## ‚¨ÖÔ∏è Librer√≠a que permite manejar el error de un token inv√°lido
from jwt.exceptions import ExpiredSignatureError ## ‚¨ÖÔ∏è Librer√≠a que permite manejar el error de un token expirado
from passlib.context import CryptContext ## ‚¨ÖÔ∏è Librer√≠a que permitir√° utilizar el algoritmo de encriptaci√≥n en un contexto

from fastapi import Depends ## ‚¨ÖÔ∏è Librer√≠a que permite establecer que una funci√≥n depende
                            ##     de el resultado de otra funci√≥n. 

from datetime import datetime  ## ‚¨ÖÔ∏è Librer√≠a que permite el manejo de fecha y hora
from datetime import timedelta ## ‚¨ÖÔ∏è Librer√≠a que permite realizar c√°lculos entre fechas
from datetime import timezone  ## ‚¨ÖÔ∏è Librer√≠a que permite traer la fecha y hora en base a una zona de localizaci√≥n

## ‚úÖ Router generado para instanciar en main.py
router_usuarios = APIRouter(
    prefix="/usuarios",
    responses={404:{"message":"Ruta no encontrada"}}, 
    tags=["usuarios"] 
)

## üí° Permite establecer que en el endpoint /login se generar√° y retornar√° un access_token.
oauth2 = OAuth2PasswordBearer(tokenUrl="login") ## ‚úÖ Establece el contexto de autenticaci√≥n y autorizaci√≥n en FastAPI.



## ----- Definiendo variables constantes que ser√°n definidas para su uso constante (Buenas pr√°cticas)

ALGORITHM = "HS256" ## ‚¨ÖÔ∏è Algoritmo establecido almacenado en una variable constante
ACCESS_TOKEN_DURATION = 1 ## ‚¨ÖÔ∏è Tiempo de duraci√≥n del access token en minutos almacenado en una variable constante
SECRET = "12345" ## ‚¨ÖÔ∏è Llave secreta que solo el backend conoce y permite la encriptaci√≥n / desencriptaci√≥n segura (se gener√≥ con: openssl rand -hex 32)
## üí° En este caso, yo he modificado la secret para evitar alg√∫n intento de hackeo.
## RECUERDA QUE SI TIENES UN PROYECTO EN GITHUB, NO DESPLIEGUES ESTA LLAVE SECRETA.


## ---- Definiendo contexto de encriptaci√≥n mediante el algoritmo
crypt = CryptContext(schemes=["bcrypt"])


## ‚úÖ Clase Usuario que hereda el formato de BaseModel
class Usuario(BaseModel):
    nombre : str
    apellido : str
    edad : int
    username : str
    disabled : bool

## ‚úÖ Clase UsuarioBD que permite exponer solo lo necesario para la bd
class UsuarioBD(Usuario):
    password : str
  ## üí° Creamos esta clase adicional que hereda de la anterior para poder exponer
  ##    los atributos necesarios al momento de la autenticaci√≥n del usuario y no
  ##    exponer informaci√≥n sensible como el password en las respuestas de la API.


## ‚úÖ Base de Datos simulada.

usuarios_bd = {
    "rcero3":{
        "nombre":"Brayan ",
        "apellido":"Neciosup",
        "edad":20,
        "username":"rcero3",
        "disabled": False,
        "password":"$2a$12$ddZlf1469ksLHloQ6z6r6.HjdG0AfV5hjYww95IsAyyGzUvg.ZSbi" ## En este caso la contrase√±a ser√° encriptada (Desencriptada es: 12345)
    },
    "rcero2":{
        "nombre":"Brayan",
        "apellido":"Neciosup 2",
        "edad":25,
        "username":"rcero2",
        "disabled": True,
        "password":"$2a$12$Zhzz9fZLUoELtB8PGM4yrOKQdeFCGKgFgxdpVjPkOwuFMQAS3ivDC" ## En este caso la contrase√±a ser√° encriptada (Desencriptada es: 54321)
    }
}

## ‚úÖ Funci√≥n que permite realizar la b√∫squeda de un usuario en base a su "username"
## üí° Importante: En esta funci√≥n retornamos valores escenciales para el escenario de BD,
##                es decir, retornamos el password en el objeto para su posterior validaci√≥n.
def buscar_usuario_bd(username:str):
    return UsuarioBD(**usuarios_bd.get(username))

## ‚úÖ Funci√≥n que permite realizar la b√∫squeda de un usuario en base a su "username".
## üí° Importante: En esta funci√≥n retornamos valores escenciales para el escenario de datos del usuario,
##                es decir, retornamos los campos necesarios para su uso.
def buscar_usuario(username:str):
    return Usuario(**usuarios_bd.get(username))

##==== El uso de "**" permite el desempaquetamiento de los valores y su asignaci√≥n a cada atributos de las clases

## ‚úÖ Funci√≥n que permite validar el ACCESS TOKEN mediante su desencriptaci√≥n y
##    que recibe respuesta del token generado por la ruta (/login) que oauth2 hab√≠a establecido.
async def auth_user_jwt(token : str = Depends(oauth2)):
    exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,detail="Credenciales de autenticaci√≥n inv√°lidas",
                            headers={"WWW-Authenticate":"Bearer"}) ## Al ser un error muy com√∫n, lo almacenamos en una variable para reutilizar c√≥digo.
    
    ## üí° Validamos que el token sea correcto
    try:
        
        username = jwt.decode(token,key=SECRET,algorithms=[ALGORITHM]).get("sub") ## üí° Desencriptamos el ACCESS TOKEN y extraemos su cuerpo (username)
        if username is None: ## üí° Validamos que el username no sea un vac√≠o
            raise exception
    except ExpiredSignatureError:
        raise HTTPException(status_code=status.HTTP_408_REQUEST_TIMEOUT,detail="El token ha expirado",headers={"WWW-Authenticate":"Bearer"})
    
    except InvalidTokenError:
        raise exception

    return buscar_usuario(username) ## üí° Si todo se valid√≥ correctamente, llamamos a la funci√≥n buscar_usuario y
                                    ##    retornamos los datos completos de ese usuario.


## ‚úÖ Funci√≥n que recibe respuesta de los datos de usuario de la funci√≥n auth_user_jwt().
async def current_user (usuario:Usuario = Depends(auth_user_jwt)): ## ‚¨ÖÔ∏è Depends() permite establecer que, el token generado
                                                             ##    servir√° como par√°metro en esta funci√≥n.

    ## ----- Realizamos validaciones de reglas de negocio para los usuarios.
    if usuario.disabled: ## üí° Permite verificar que el usuario no est√© inactivo
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,detail="Usuario Inactivo")
    
    ## ---- Si todo fue validado correctamente, se retorna el usuario con sus datos no sensibles (Ejemp. Sin password).
    return usuario


## ‚úÖ Funci√≥n establecida por oauth2 para el retorno de un ACCESS TOKEN, adem√°s
##     permite el inicio de sesi√≥n de los usuarios de manera segura gracias a OAuth2PasswordRequestForm.
@router_usuarios.post("/login",status_code=status.HTTP_200_OK)
async def login(form:OAuth2PasswordRequestForm = Depends()): ## ‚¨ÖÔ∏è Depends() indica que esta funci√≥n no depender√° del resultado
    usuario_bd = usuarios_bd.get(form.username)             ##     de otra funci√≥n, pero, si ser√° el que envie su respuesta a otra.
    ## üí° Buscamos el usuario en base al username para validar su existencia.

    if not usuario_bd: ## üí° Valida que el usuario exista
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,detail="El usuario no es correcto")
    
    usuario = buscar_usuario_bd(form.username) ## üí° Buscamos y almacenamos el usuario en base al username.
    if not crypt.verify(form.password,usuario.password) : ## üí° Valida que la contrase√±a en texto plano sea igual a la
                                                          ##    contrase√±a encriptada en la BD simulada.
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,detail="La contrase√±a es incorrecta")
    
    ## --- ‚úÖ Definiendo ACCESS TOKEN JWT
    
    ##-- Paso A). Definir el tiempo de expiraci√≥n
    tiempo_expiracion_access_token = datetime.now(timezone.utc)+timedelta(minutes=ACCESS_TOKEN_DURATION)
        ## ‚û°Ô∏è datetime.now(): Permite retornar la fecha y hora del servidor de internet (No es la misma de nuestra zona local).
        ## ‚û°Ô∏è timeszone.utc: Permite retornar la fecha y hora de nuestra zona local y redefinir el datetime.now().
        ## ‚û°Ô∏è timedelta(minute=ACCESS_TOKEN_DURATION): Permite agregar un minuto a la fecha y hora de nuestra zona local
    
    ##-- Paso B). Definir JWT
    access_token = {
        "sub": usuario.username,
        "exp": tiempo_expiracion_access_token
    }
    
    ##-- Paso C). Encriptar JWT
    return {"access_token":jwt.encode(access_token,key=SECRET,algorithm=ALGORITHM),"token_type":"bearer"}
        ## ‚û°Ô∏è jwt.encode(): Permite encriptar el access token, a trav√©s de una llave y algoritmo.
        ## ‚û°Ô∏è key: Es la llave que encriptar√° el access token.
        ## ‚û°Ô∏è algorithm: Es el algoritmo utilizado para encriptar el access token.


    ## ---- Si todo fue correcto, retornamos un ACCESS TOKEN. En este caso, es un ACCESS TOKEN sigue siendo el username, pero, encriptado.
    
    
## ‚úÖ Funci√≥n protegida por la autenticaci√≥n mediante el ACCESS TOKEN,
##     es decir, si el ACCESS TOKEN no es correcto, no podemos acceder a los recursos
##     que brinde este endpoint.
@router_usuarios.get("/users/me")
async def user_me(usuario:Usuario = Depends(current_user)): ## ‚¨ÖÔ∏è Depends() indica que esta funci√≥n depender√° de una respuesta
    return usuario                                          ##    de otra funci√≥n, en este caso current_user.


## ‚úÖ LEVANTAR ESTA API: En este caso, levantaremos las APIs desde el archivo principal (main).